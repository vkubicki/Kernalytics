# Code overview

This document provides a global overview of Kernalytics, highlighting the most important aspects. In particular it provides a link between kernel mathematics and implementations, exposing the modular nature of Kernalytics. Note that a more detailed description of the I/O operations and a detailed call sequence can be found at [algorithm description](/doc/algoDesc.md).

- [AlgebraAbstract](/src/main/scala/rkhs/AlgebraAbstract.scala): kernels are grouped in families which are based on algebraic data structure. The algebraic structures are created as traits, with unimplemented operations that depend on data types. For example, in `InnerProductSpace`, the operations `minus` and `ip` (for inner product). However in `getKernel`, the kernels are defined and use `minus` and `ip`. Therefor, if a class extends `InnerProductSpace` for a given type and defines `minus` and `ip`, then the kernels are automatically defined and are usable for this type.
- [AlgebraImplementation](/src/main/scala/rkhs/AlgebraImplementation.scala): this is where the algebraic data structures are implemented for a given type. For example, for real numbers, `minus` is defined as `-`, and `ip` as `*` in `R.InnerProductSpace`. The code is quite flexible, so specific kernels which do not depend on an algebraic structure should be added in this file as well.
- [KerEval](/src/main/scala/rkhs/KerEval.scala): basic abstraction for kernel evaluation. It is more than just a function, because it abstracts the underlying data type, and offer some computation optimization. For example, kernel evaluation can be computed on the fly or cached, through various specializations of the `KerEval` trait. All algorithms then can evaluate the kernel at data points, and still ignore the origin of the data.
